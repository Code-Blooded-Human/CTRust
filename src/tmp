"as"   		       	{  return KEYWORD_STRICT_AS;  }
"break"		        {  return KEYWORD_STRICT_BREAK;  }
"const"		      	{  return KEYWORD_STRICT_CONST;  }
"continue"			  {  return KEYWORD_STRICT_CONTINUE;  }
"crate"           {  return KEYWORD_STRICT_CRATE;  }
"else"           	{  return KEYWORD_STRICT_ELSE;  }
"enum"           	{  return KEYWORD_STRICT_ENUM;  }
"extern"          {  return KEYWORD_STRICT_EXTERN;  }
"false"           {  return KEYWORD_STRICT_FALSE;  }
"fn"           		{  return KEYWORD_STRICT_FN;  }
"for"         		{  return KEYWORD_STRICT_FOR;  }
"if"           		{  return KEYWORD_STRICT_IF;  }
"impl"           	{  return KEYWORD_STRICT_IMPL;  }
"in"           		{  return KEYWORD_STRICT_IN;  }
"let"         		{  return KEYWORD_STRICT_LET;  }
"loop"         		{  return KEYWORD_STRICT_LOOP;  }
"match"        		{  return KEYWORD_STRICT_MATCH;  }
"mod"         		{  return KEYWORD_STRICT_MOD;  }
"move"         		{  return KEYWORD_STRICT_MOVE;  }
"mut"         		{  return KEYWORD_STRICT_MUT;  }
"pub"         		{  return KEYWORD_STRICT_PUB;  }
"ref"         		{  return KEYWORD_STRICT_REF;  }
"return"       		{  return KEYWORD_STRICT_RETURN;  }
"self"         		{  return KEYWORD_STRICT_SELFVALUE;  }
"Self"         		{  return KEYWORD_STRICT_SELFTYPE;  }
"static"         	{  return KEYWORD_STRICT_STATIC;  }
"struct"         	{  return KEYWORD_STRICT_STRUCT;  }
"super"         	{  return KEYWORD_STRICT_SUPER;  }
"trait"         	{  return KEYWORD_STRICT_TRAIT;  }
"true"         		{  return KEYWORD_STRICT_TRUE;  }
"type"         		{  return KEYWORD_STRICT_TYPE;  }
"unsafe"         	{  return KEYWORD_STRICT_UNSAFE;  }
"use"         		{  return KEYWORD_STRICT_USE;  }
"where"         	{  return KEYWORD_STRICT_WHERE;  }
"while"         	{  return KEYWORD_STRICT_WHILE;  }

"async"         	{  return KEYWORD_STRICT_ASYNC;  }
"await"         	{  return KEYWORD_STRICT_AWAIT;  }
"dyn"	         	  {  return KEYWORD_STRICT_DYN;  }


"abstract"        {  return KEYWORD_RES_ABSTRACT;  }
"become"          {  return KEYWORD_RES_BECOME;  }
"box"             {  return KEYWORD_RES_BOX;  }
"do"              {  return KEYWORD_RES_DO;  }
"final"           {  return KEYWORD_RES_FINAL;  }
"macro"           {  return KEYWORD_RES_MACRO;  }
"override"        {  return KEYWORD_RES_OVERRIDE;  }
"priv"            {  return KEYWORD_RES_PRIV;  }
"typeof"          {  return KEYWORD_RES_TYPEOF;  }
"unsized"         {  return KEYWORD_RES_UNSIZED;  }
"virtual"         {  return KEYWORD_RES_VIRTUAL;  }
"yield"           {  return KEYWORD_RES_YILED;  }

"try"             {  return KEYWORD_RES_TRY;  }


"union"           {  return KEYWORD_WEAK_UNION;  }
"'static"         {  return KEYWORD_WEAK_STATICLIFETIME;  }

"dyn"           {  return KEYWORD_WEAK_DYN;  }




"+"			{  return ADDOP;   }
"-"                     {  return SUBOP;   }
"*"                     {  return MULOP;   }
"/"                     {  return DIVOP;   }
"++" 			{  return INCR;   }
"--"                    {  return DECR;   }
"||"                    {  return OROP;   }
"&&"                    {  return ANDOP;   }
"!"                     {  return NOTOP;   }
"=="                    {  return EQUOP;   }
"!="			{  return NEQUOP;   }
">"		        {  return GT;   }
"<"			{  return LT;   }
">="			{  return GTEQ;   }
"<="			{  return LTEQ;   }
":"             {  return COLON;   }
"("             {  return LPAREN;    }
")"             {  return RPAREN;   }
"]"             {  return LBRACK;   }
"["             {  return RBRACK;   }
"{"             {  return LBRACE;   }
"}"             {  return RBRACE;   }
";"             {  return SEMI;   }
".."             {  return DOTDOT;   }
"."             {  return DOT;   }
","             {  return COMMA;   }
"="             {  return ASSIGN;   }
"&"             {  return REFER;   }


{ID}            {  return ID;   }
{ICONST}        {  return ICONST;   }
{FCONST}        {  return FCONST;   }
{CCONST}        {  return CCONST;   }
{STRING}        {  return STRING;   }




%token KEYWORD_STRICT_AS
%token KEYWORD_STRICT_BREAK
%token KEYWORD_STRICT_CONST
%token KEYWORD_STRICT_CONTINUE
%token KEYWORD_STRICT_CRATE
%token KEYWORD_STRICT_ELSE
%token KEYWORD_STRICT_ENUM
%token KEYWORD_STRICT_EXTERN
%token KEYWORD_STRICT_FALSE
%token KEYWORD_STRICT_FN
%token KEYWORD_STRICT_FOR
%token KEYWORD_STRICT_IF
%token KEYWORD_STRICT_IMPL
%token KEYWORD_STRICT_IN
%token KEYWORD_STRICT_LET
%token KEYWORD_STRICT_LOOP
%token KEYWORD_STRICT_MATCH
%token KEYWORD_STRICT_MOD
%token KEYWORD_STRICT_MOVE
%token KEYWORD_STRICT_MUT
%token KEYWORD_STRICT_PUB
%token KEYWORD_STRICT_REF
%token KEYWORD_STRICT_RETURN
%token KEYWORD_STRICT_SELFVALUE
%token KEYWORD_STRICT_SELFTYPE
%token KEYWORD_STRICT_STATIC
%token KEYWORD_STRICT_STRUCT
%token KEYWORD_STRICT_SUPER
%token KEYWORD_STRICT_TRAIT
%token KEYWORD_STRICT_TRUE
%token KEYWORD_STRICT_TYPE
%token KEYWORD_STRICT_UNSAFE
%token KEYWORD_STRICT_USE
%token KEYWORD_STRICT_WHERE
%token KEYWORD_STRICT_WHILE
%token KEYWORD_STRICT_ASYNC
%token KEYWORD_STRICT_AWAIT
%token KEYWORD_STRICT_DYN
%token KEYWORD_RES_ABSTRACT
%token KEYWORD_RES_BECOME
%token KEYWORD_RES_BOX
%token KEYWORD_RES_DO
%token KEYWORD_RES_FINAL
%token KEYWORD_RES_MACRO
%token KEYWORD_RES_OVERRIDE
%token KEYWORD_RES_PRIV
%token KEYWORD_RES_TYPEOF
%token KEYWORD_RES_UNSIZED
%token KEYWORD_RES_VIRTUAL
%token KEYWORD_RES_YILED
%token KEYWORD_RES_TRY
%token KEYWORD_WEAK_UNION
%token KEYWORD_WEAK_STATICLIFETIME
%token KEYWORD_WEAK_DYN
%token ADDOP
%token SUBOP
%token MULOP
%token DIVOP
%token INCR
%token DECR
%token OROP
%token ANDOP
%token NOTOP
%token EQUOP
%token NEQUOP
%token GT
%token LT
%token GTEQ
%token LTEQ
%token COLON
%token LPAREN
%token RPAREN
%token LBRACK
%token RBRACK
%token LBRACE
%token RBRACE
%token SEMI
%token DOTDOT
%token DOT
%token COMMA
%token ASSIGN
%token REFER
%token ID
%token ICONST
%token FCONST
%token CCONST
%token STRING


input:    /* empty */
        | input line
;

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

exp:      NUM             { $$ = $1;         }
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        | exp exp '*'     { $$ = $1 * $2;    }
        | exp exp '/'     { $$ = $1 / $2;    }
      /* Exponentiation */
        | exp exp '^'     { $$ = pow ($1, $2); }
      /* Unary minus    */
        | exp 'n'         { $$ = -$1;        }
;



// expr refers to expressions that end with semicolon.
    expr:
    | expr varDec expr
    ;

// exprBlock refers to if(){} and loop block
    exprBlock:
    ;


// BLOCK refers to anything that comes inside {}
    block:
    | block block
    | expr
    | exprBlock
    ;
%%